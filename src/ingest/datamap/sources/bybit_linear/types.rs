// ingest/exchanges/bybit/types.rs (partial: DEPTH SNAPSHOT only)
use crate::error::{AppError, AppResult};
use crate::ingest::datamap::traits::FromJsonStr;
use serde::Deserialize;

// Same shape as Binance module
pub type PriceLevel = [String; 2];

#[derive(Debug, Clone, Deserialize)]
struct BybitRestResponse<T> {
    #[serde(rename = "retCode")]
    pub ret_code: i64,
    #[serde(rename = "retMsg")]
    pub ret_msg: String,
    pub result: T,
    // keep these for debugging / future use
    #[serde(default)]
    pub time: Option<u64>,
    #[serde(rename = "retExtInfo", default)]
    pub ret_ext_info: serde_json::Value,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearDepthSnapshot {
    /// Symbol (e.g. BTCUSDT)
    #[serde(rename = "s")]
    pub symbol: String,

    /// Bids: [[price, size], ...]
    #[serde(rename = "b")]
    pub bids: Vec<PriceLevel>,

    /// Asks: [[price, size], ...]
    #[serde(rename = "a")]
    pub asks: Vec<PriceLevel>,

    /// Timestamp (ms) generated by system (as in docs)
    #[serde(rename = "ts")]
    pub ts_ms: u64,

    /// Update id
    #[serde(rename = "u")]
    pub update_id: u64,

    /// Cross sequence
    #[serde(rename = "seq")]
    pub seq: u64,

    /// "cts" (ms) as returned by API
    #[serde(rename = "cts")]
    pub cts_ms: u64,
}

impl FromJsonStr for BybitLinearDepthSnapshot {
    fn from_json_str(s: &str) -> AppResult<Self> {
        let resp: BybitRestResponse<BybitLinearDepthSnapshot> =
            serde_json::from_str(s).map_err(AppError::Json)?;

        if resp.ret_code != 0 {
            return Err(AppError::InvalidConfig(format!(
                "bybit depth snapshot retCode={} retMsg={}",
                resp.ret_code, resp.ret_msg
            )));
        }

        Ok(resp.result)
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearExchangeInfoSnapshot {
    pub category: String,

    #[serde(rename = "list")]
    pub instruments: Vec<BybitLinearInstrumentInfo>,

    #[serde(rename = "nextPageCursor", default)]
    pub next_page_cursor: Option<String>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearInstrumentInfo {
    pub symbol: String,

    #[serde(rename = "contractType")]
    pub contract_type: String,

    pub status: String,

    #[serde(rename = "baseCoin")]
    pub base_coin: String,

    #[serde(rename = "quoteCoin")]
    pub quote_coin: String,

    #[serde(rename = "launchTime")]
    pub launch_time_ms: String,

    #[serde(rename = "deliveryTime")]
    pub delivery_time_ms: String,

    #[serde(rename = "deliveryFeeRate")]
    pub delivery_fee_rate: String,

    #[serde(rename = "priceScale")]
    pub price_scale: String,

    #[serde(rename = "leverageFilter")]
    pub leverage_filter: BybitLeverageFilter,

    #[serde(rename = "priceFilter")]
    pub price_filter: BybitPriceFilter,

    #[serde(rename = "lotSizeFilter")]
    pub lot_size_filter: BybitLotSizeFilter,

    #[serde(rename = "unifiedMarginTrade")]
    pub unified_margin_trade: bool,

    #[serde(rename = "fundingInterval")]
    pub funding_interval: u64,

    #[serde(rename = "settleCoin")]
    pub settle_coin: String,

    #[serde(rename = "copyTrading")]
    pub copy_trading: String,

    #[serde(rename = "upperFundingRate")]
    pub upper_funding_rate: String,

    #[serde(rename = "lowerFundingRate")]
    pub lower_funding_rate: String,

    #[serde(rename = "isPreListing")]
    pub is_pre_listing: bool,

    #[serde(rename = "preListingInfo", default)]
    pub pre_listing_info: Option<serde_json::Value>,

    #[serde(rename = "riskParameters")]
    pub risk_parameters: BybitRiskParameters,

    #[serde(rename = "displayName")]
    pub display_name: String,

    #[serde(rename = "symbolType")]
    pub symbol_type: String,

    #[serde(rename = "forbidUplWithdrawal")]
    pub forbid_upl_withdrawal: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLeverageFilter {
    #[serde(rename = "minLeverage")]
    pub min_leverage: String,
    #[serde(rename = "maxLeverage")]
    pub max_leverage: String,
    #[serde(rename = "leverageStep")]
    pub leverage_step: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitPriceFilter {
    #[serde(rename = "minPrice")]
    pub min_price: String,
    #[serde(rename = "maxPrice")]
    pub max_price: String,
    #[serde(rename = "tickSize")]
    pub tick_size: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLotSizeFilter {
    #[serde(rename = "maxOrderQty")]
    pub max_order_qty: String,
    #[serde(rename = "minOrderQty")]
    pub min_order_qty: String,
    #[serde(rename = "qtyStep")]
    pub qty_step: String,
    #[serde(rename = "postOnlyMaxOrderQty")]
    pub post_only_max_order_qty: String,
    #[serde(rename = "maxMktOrderQty")]
    pub max_mkt_order_qty: String,
    #[serde(rename = "minNotionalValue")]
    pub min_notional_value: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitRiskParameters {
    #[serde(rename = "priceLimitRatioX")]
    pub price_limit_ratio_x: String,
    #[serde(rename = "priceLimitRatioY")]
    pub price_limit_ratio_y: String,
}

impl FromJsonStr for BybitLinearExchangeInfoSnapshot {
    fn from_json_str(s: &str) -> AppResult<Self> {
        let resp: BybitRestResponse<BybitLinearExchangeInfoSnapshot> =
            serde_json::from_str(s).map_err(AppError::Json)?;

        if resp.ret_code != 0 {
            return Err(AppError::InvalidConfig(format!(
                "bybit exchange_info retCode={} retMsg={}",
                resp.ret_code, resp.ret_msg
            )));
        }

        Ok(resp.result)
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearServerTimeSnapshot {
    #[serde(rename = "timeSecond")]
    pub time_second: String,

    #[serde(rename = "timeNano")]
    pub time_nano: String,
}

impl FromJsonStr for BybitLinearServerTimeSnapshot {
    fn from_json_str(s: &str) -> AppResult<Self> {
        let resp: BybitRestResponse<BybitLinearServerTimeSnapshot> =
            serde_json::from_str(s).map_err(AppError::Json)?;

        if resp.ret_code != 0 {
            return Err(AppError::InvalidConfig(format!(
                "bybit server_time retCode={} retMsg={}",
                resp.ret_code, resp.ret_msg
            )));
        }

        Ok(resp.result)
    }
}

//
// ---- WS: Depth Update (Bybit Linear) ----
//

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearWsDepthUpdate {
    pub topic: String,

    /// "snapshot" | "delta"
    #[serde(rename = "type")]
    pub update_type: String,

    /// Event timestamp (ms)
    pub ts: u64,

    pub data: BybitLinearWsDepthData,

    /// Cross timestamp (ms)
    pub cts: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearWsDepthData {
    /// Symbol
    #[serde(rename = "s")]
    pub symbol: String,

    /// Bids: [[price, size], ...]
    #[serde(rename = "b")]
    pub bids: Vec<PriceLevel>,

    /// Asks: [[price, size], ...]
    #[serde(rename = "a")]
    pub asks: Vec<PriceLevel>,

    /// Update id
    #[serde(rename = "u")]
    pub update_id: u64,

    /// Cross sequence
    #[serde(rename = "seq")]
    pub seq: u64,
}

impl FromJsonStr for BybitLinearWsDepthUpdate {
    fn from_json_str(s: &str) -> AppResult<Self> {
        serde_json::from_str(s).map_err(AppError::Json)
    }
}

//
// ---- WS: All Liquidation (Bybit Linear) ----
//

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearWsLiquidation {
    pub topic: String,

    /// "snapshot"
    #[serde(rename = "type")]
    pub update_type: String,

    /// Event timestamp (ms)
    pub ts: u64,

    /// One or more liquidation events
    pub data: Vec<BybitLinearLiquidationData>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearLiquidationData {
    /// Trade time (ms)
    #[serde(rename = "T")]
    pub trade_time_ms: u64,

    /// Symbol
    #[serde(rename = "s")]
    pub symbol: String,

    /// Side of taker: "Buy" | "Sell"
    #[serde(rename = "S")]
    pub side: String,

    /// Size
    #[serde(rename = "v")]
    pub qty: String,

    /// Price
    #[serde(rename = "p")]
    pub price: String,
}

impl FromJsonStr for BybitLinearWsLiquidation {
    fn from_json_str(s: &str) -> AppResult<Self> {
        serde_json::from_str(s).map_err(AppError::Json)
    }
}

//
// ---- WS: OI + Funding (Bybit Linear tickers) ----
//
// NOTE: Bybit tickers stream sends:
// - type = "snapshot": many fields present
// - type = "delta": only changed fields present (sparse)
// So we model `data` as a struct with lots of Option<String> fields.
//

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearWsOIFundingUpdate {
    pub topic: String,

    /// "snapshot" | "delta"
    #[serde(rename = "type")]
    pub update_type: String,

    pub data: BybitLinearTickerData,

    /// Cross sequence
    #[serde(rename = "cs")]
    pub cs: u64,

    /// Timestamp (ms)
    pub ts: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearTickerData {
    pub symbol: String,

    // --- prices / marks (often present in snapshot, sometimes in delta) ---
    #[serde(default)]
    pub markPrice: Option<String>,
    #[serde(default)]
    pub indexPrice: Option<String>,
    #[serde(default)]
    pub lastPrice: Option<String>,

    // --- Open interest ---
    #[serde(default)]
    pub openInterest: Option<String>,
    #[serde(default)]
    pub openInterestValue: Option<String>,

    // --- Funding ---
    #[serde(default)]
    pub fundingRate: Option<String>,
    #[serde(default)]
    pub nextFundingTime: Option<String>,
    #[serde(default)]
    pub fundingIntervalHour: Option<String>,
    #[serde(default)]
    pub fundingCap: Option<String>,

    // --- top of book (often changes) ---
    #[serde(default)]
    pub bid1Price: Option<String>,
    #[serde(default)]
    pub bid1Size: Option<String>,
    #[serde(default)]
    pub ask1Price: Option<String>,
    #[serde(default)]
    pub ask1Size: Option<String>,

    // --- 24h stats (sometimes in delta) ---
    #[serde(default)]
    pub price24hPcnt: Option<String>,
    #[serde(default)]
    pub prevPrice24h: Option<String>,
    #[serde(default)]
    pub highPrice24h: Option<String>,
    #[serde(default)]
    pub lowPrice24h: Option<String>,
    #[serde(default)]
    pub prevPrice1h: Option<String>,
    #[serde(default)]
    pub turnover24h: Option<String>,
    #[serde(default)]
    pub volume24h: Option<String>,

    // --- misc fields present in snapshot ---
    #[serde(default)]
    pub tickDirection: Option<String>,
    #[serde(default)]
    pub preOpenPrice: Option<String>,
    #[serde(default)]
    pub preQty: Option<String>,
    #[serde(default)]
    pub curPreListingPhase: Option<String>,
}

impl FromJsonStr for BybitLinearWsOIFundingUpdate {
    fn from_json_str(s: &str) -> AppResult<Self> {
        serde_json::from_str(s).map_err(AppError::Json)
    }
}

//
// ---- WS: Trades (Bybit Linear publicTrade) ----
//

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearWsTrade {
    pub topic: String,

    /// "snapshot" (Bybit uses snapshot-style batches)
    #[serde(rename = "type")]
    pub update_type: String,

    /// Event timestamp (ms)
    pub ts: u64,

    /// One or more trades (ascending by match time)
    pub data: Vec<BybitLinearTradeData>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BybitLinearTradeData {
    /// Fill time (ms)
    #[serde(rename = "T")]
    pub trade_time_ms: u64,

    /// Symbol
    #[serde(rename = "s")]
    pub symbol: String,

    /// Taker side: "Buy" | "Sell"
    #[serde(rename = "S")]
    pub side: String,

    /// Trade size
    #[serde(rename = "v")]
    pub qty: String,

    /// Trade price
    #[serde(rename = "p")]
    pub price: String,

    /// Price change direction (perps/futures)
    #[serde(rename = "L")]
    pub tick_direction: String,

    /// Trade id (UUID string)
    #[serde(rename = "i")]
    pub trade_id: String,

    /// Block trade?
    #[serde(rename = "BT")]
    pub is_block_trade: bool,

    /// RPI trade?
    #[serde(rename = "RPI")]
    pub is_rpi: bool,

    /// Cross sequence
    pub seq: u64,
}

impl FromJsonStr for BybitLinearWsTrade {
    fn from_json_str(s: &str) -> AppResult<Self> {
        serde_json::from_str(s).map_err(AppError::Json)
    }
}
